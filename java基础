0.java基础
重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。
面向对象语言三大特性：封装（减少耦合、隐藏信息）、继承（构造方法、protected关键字、向上转型 需注意的是强耦合，需谨慎继承 是否需要向上转型）
多态：一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定  三个必要条件：继承、重写、向上转型
==和equals区别：String重写了Object的equals方法，对于字符串而言比较两字符串内容，非字符串比较两对象是否相同；==用来比较两对象是否相同，即地址是否相同，基本类型数据只能用==比较。
Lock、sychronized、volatile区别：sychronized能保证原子性、顺序性和可见性，是一种重量级同步锁，可以作用在对象、方法、代码块中，但锁都是对象锁，性能较差。Volatile只能保证原子性和顺序性，作用在变量上，保证变量每次的使用都是最新值，而不是从内存读取的值，顺序性表示在调用变量之前，其前面的代码一定都已经执行完毕。Lock锁可分为公平锁和非公平锁，也可分化排它锁（reentrantLock）和排它锁、共享锁结合的reentrantwriteReadLock，其中写操作为排它锁，读操作为共享锁，性能更优，另外，lock为java类，发生异常不会主动释放锁，所以通常用try…catch…finally配合，在finally代码块中释放锁。
时间片：即CPU分配给各个程序的运行时间，每个线程被分配一个时间段，称为此线程的时间片。
上下文切换：当前执行任务执行完时间片切换到另一个任务之前会先保存自己的状态，以便下次加载，任务从保存到再加载的过程就是一次上下文切换。上下文切换意味着消耗大量的CPU时间。两种方式：让步式上下文切换和抢占式上下文切换。前者是指执行线程主动释放CPU，与锁竞争严重程度成正比，可通过减少锁竞争来避免；后者是指线程因分配的时间片用尽而被迫放弃CPU或者被其他优先级更高的线程所抢占，一般由于线程数大于CPU可用核心数引起，可通过调整线程数，适当减少线程数来避免。①高并发，低耗时的情况，上下文切换 本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片, 反而会增加线程切换的开销.②低并发，高耗时，保证有空闲线程，接收新任务，可以减少线程切换。
CAS：CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。
内存泄漏：


1.java反射机制与动态代理
反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用这个对象的所有属性和方法，这种动态获取信息以及动态调用对象方法的功能称为java反射机制。简单的说，java对每一个类和类的属性和方法进行了封装，每个类都有一个与之对应的class对象，通过这个对象可以访问类中的所有成员。
反射机制可以增加程序的灵活性以及封装性，在编译阶段不出错，在运行阶段才会出错。
静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了
动态代理：在程序运行时运用反射机制动态创建而成（实现invocationhandler接口，调用invoker.method）
代理相当于中介，把被代理对象包装一层，在其内部做一些额外的工作

2.AOP面向切片编程
指在程序运行期间将某段代码，动态的切入到某个类的指定方法的指定位置的这种编程思想，是OOP编程思想的补充（比如一个系统在进行相关操作时都需要验证用户，那么久可以把验证用户步骤动态的切入到指定位置），优点是：只需要事先考虑主流程，对于公共功能可以在需要的时候插入到特定位置
代理：三要素（共同接口、真实对象、代理对象）简单的代理，相当于真实对象的另一层封装，其优点是扩展原功能，不侵入源代码  
动态代理：因静态代理难以满足对多个真实对象的代理，因此动态代理应运而生，其目的是实现对任何对象、任何方法的代理。（单纯依靠反射很难  动态生成（传入二要素返回proxy接口）+代理模式）JDK中的InvocationHandler，利用invoke方法（JDK动态代理模式、CGLIB可以返回实现类）。（待深入）
SpringAop实现：AspectJ是一个AOP框架，能够对java代码进行AOP编译，让java代码具有AspectJ的AOP功能，Spring框架借鉴AspectJ的注解，但AOP实现依然是采用动态代理JDK或CGLIB实现。@Aspect定义切面类，在切面类的方法前@before位置切入特定要执行的代码。

3.java对象持久化与序列化
对象持久化：就是让对象的生存期超越使用对象的程序的运行期，将对象存储在可持久保存的存储介质上，把对象永久的保存到数据库或本地硬盘中，也包括和数据库相关的各种操作。
优点是：持久化技术可以减少访问数据库次数，增加应用程序执行速度，代码重用性高，松散耦合。
序列化：把Java对象转换为字节序列的过程称为对象的序列化；把字节序列恢复为Java对象的过程称为对象的反序列化
持久化就是把内存中的对象保存到外存中，让以后能够取回。而保存和取回的过程就是经过序列化和对象io完成的

4.Redis相关
Redis是key-value型数据库，支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及sorted set(有序集合)，redis是在服务接口和DB之间增加的一个缓存层（集群模式下的公共缓存）
Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复
Redis优点：1.支持多数据类型，2.支持主从模式 3.支持持久化 4.单个value限制是1GB 5.与其他缓存数据库相比，支持持久化

5.java分布式项目
分布式项目线程安全性：mybatis-spring框架下sqlsession能够保证线程安全性，原因
Spring生成sqlsession的单例，然后把session的持有者绑定到事务管理中，只要是在改事务中的操作都可以使用这个sqlsession，这样他们一定是在同一线程中，动作一定互斥，以此保证线程安全性。
Session：会话控制 （一系列有始有终的动作或消息）现在更多是用于在客户端和服务器之间保持状态的解决方案。


6.dubbo分布式框架及原理
Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案，特点是分层设计，可以最大限度的松耦合。
Dubbo原理，第一步：服务装载容器中，然后准备注册服务（先读配置文件解析服务）；第二步暴露服务，直接暴露服务端口或向注册中心暴露服务；第三步，直接引用服务或者从注册中心中发现引用服务
Zookeeper在dubbo中的作用：zookeeper类似于dubbo服务的注册中心
dubbo的服务提供者会在zookeeper上面创建一个临时节点，表明自己的ip和端口，当消费者需要使用服务时，会先在zookeeper上面查询，找到服务提供者，做一些负载的选择（比如随机、轮流），然后按照这些信息，访问服务提供者。
zookeeper负责保存了服务提供方和服务消费方的的URI（dubbo自定义的一种URI），服务消费方找到zookeeper，向zookeeper要到服务提供方的URI，然后就找到提供方，并调用提供方的服务

8.进程间的通信方式
常见的通信方式：
	管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
	命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
	消息队列MessageQueue：消息队列，就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。
	共享存储SharedMemory：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取或读出，从而实现了进程间的通信。
	信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
	套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信，可以用于同一台或网络间的进程通信，套接字的特性由3个属性确定，它们分别是：域、类型和协议。
	信号 ( sinal ) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。信号发送的关键使得系统知道向哪个进程发送信号以及发送什么信号


9.java多线程
线程安全：在并发情况下，该代码经过多线程的使用，线程的调度顺序不影响任何结果
实现多线程的三种手段：继承Thread类、实现Runable接口或实现Callable接口配合线程池使用
线程状态：
 
	新建状态（New）：新创建了一个线程对象。
	就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
	运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
	阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
	死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
常用函数：
① sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）
② join():指等待t线程终止，该线程是指的主线程等待子线程的终止
③ yield():暂停当前正在执行的线程对象，并执行其他线程，yield()从未导致线程转到等待/睡眠/阻塞状态
④ wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行
Wait和sleep的主要区别：
方法不同： Thread类的方法：sleep(),yield()等    Object的方法：wait()和notify()等
锁的控制不同：sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法

10.servlet
	Servlet实质上就是一个java接口，里面包含了五个方法，分别为初始化方法init、获取servlet配置方法getServletConfig、提供服务方法Service、获取Servlet信息getServletInfo、销毁方法Destroy。（是运行在web端的程序）
	所有实现servlet接口的类，或者说，所有想要处理网络请求的类，都需要回答这三个问题：你初始化时要做什么？你销毁时要做什么？你接受到请求时要做什么？
	实现了servlet的类并不能直接处理请求，它不负责监听端口，不会直接和客户端打交道：servlet---servlet容器（tomcat）---客户端 
	Tomcat容器：负责监听端口，请求过来后，根据url等信息，确定要将请求交给哪个servlet去处理，然后调用那个servlet的service方法，service方法返回一个response对象，tomcat再把这个response返回给客户端
实现servlet的主要方式：继承httpservlet类、实现servlet接口
Servlet的生命周期：
1．init()。当Servlet第一次被装载时，Servlet引擎调用这个Servlet的init()方法，只调用一次。如果某个Sevlet需要特殊的初始化需要。那么Servlet编写人员可以重写该方法来执行初始化任务。这是一个可选的方法。如果某个Servlet不需要初始化，那么默认情况下将调用它父类的init方法。系统保证，在init方法成功完成以前，是不会调用Servlet去处理任何请求的。
2．service()。这是Servlet最重要的方法，是真正处理请求的地方。对于每个请求，Servlet引擎将调用Servlet的service方法，并把Servlet请求对象和Servlet响应对象最为参数传递给它。对于更多的客户端请求，Server创建新的请求和响应对象，仍然激活此servlet的service方法，将这两个对象作为参数传递给它，Servlet一般只初始化一次。
3．destroy()。这是相对于init的可选方法，当Servlet即将被卸载时由Servlet引擎来调用，这个方法用来清除并释放在init方法中所分配的资源。
Servlet与jsp的区别：
1、JSP在本质上就是SERVLET,但是两者的创建方式不一样.
2、Servlet完全是JAVA程序代码构成，擅长于流程控制和事务处理，通过Servlet来生成动态网页很不直观.
3、JSP由HTML代码和JSP标签构成，可以方便地编写动态网页.
get提交和post提交有何区别：
（1）get一般用于从服务器上获取数据，post一般用于向服务器传送数据
（2）请求的时候参数的位置有区别，get的参数是拼接在url后面，用户在浏览器地址栏可以看到。post是放在http包的包体中。比如说用户注册，你不能把用户提交的注册信息用get的方式吧，那不是说把用户的注册信息都显示在Url上了吗，是不安全的。
（3）能提交的数据有区别，get方式能提交的数据只能是文本，且大小不超过1024个字节，而post不仅可以提交文本还有二进制文件。所以说想上传文件的话，那我们就需要使用post请求方式
（4）servlet在处理请求的时候分别对应使用doGet和doPost方式进行处理请求
JSP内置对象及作用：
名称	作用
request	包含用户端请求的信息
response	包含服务器传回客户端的响应信息
session	与请求有关的会话期
pageContext	管理网页属性
application	服务器启动时创建，服务器关闭时停止，为多个应用程序保存信息
out	向客户端输出数据
config	servlet的架构部件
page	指网页本身
exception	针对错误页面才可使用
forward和redirect的区别 转发与重定向：
（1）从地址栏显示来说 
forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
（2）从数据共享来说 
forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.
（3）从运用地方来说 
forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.
Cookie与Session的区别：
1.	由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户。
2.	大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。其他会在url后添加一个sessionID，cookie可用于记住账号密码。
3.	Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

11.池的概念（线程池、数据库连接池等）
池：就是事先创建好东西放在里面，当需要时直接从池子中去拿，节省创建的时间，jdbc connection，线程thread，对象，这些东西的创建和销毁都是很消耗时间的，所以我们一般都是提前创建好很多这种创建消耗高的东西，用的时候直接去用就行。
数据库连接池：比如阿里的druid、c3p0等
线程池：java ee服务器在启动的时候，它已经创建好了很多的thread，用以来http request连接的时候，用这些创建好的thread去处理这些http连接，tomcat容器已经帮助我们创建好了。
其他的如常量池等。
Java线程池：
概念：当服务启动时，在“容器”中实现创建好多个java线程，当需要时可直接调用，同时线程池可以对线程进行管理和调用
好处：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。
Executor框架：三大部分（实现Runnable接口或Callable接口、实现任务执行机制的核心接口Executor、获得结果Future接口以及Future接口的实现类FutureTask类）
 
12.线程与进程之间区别与联系
并发：指两个或多个事件在同一时间间隔发生，即多个线程之间通过线程调度（时间切片）轮番执行；
并行：指两个或多个事件在同一时间同时发生，即多个不同实体同时处理多个事件
进程：具有独立功能的程序，是系统资源调度的一个独立单位，拥有系统资源，可以有一个或多个线程
线程：是进程的一个实体，是CPU调度和分配的基本单位，线程不拥有系统资源，同一进程的所有线程共享该进程的所有资源
不同进程的线程间要利用消息通信的方式实现同步。

13.java序列化与反序列化问题
把对象转换为字节序列的过程称为对象的序列化。
把字节序列恢复为对象的过程称为对象的反序列化。
对象的序列化主要有两种用途：1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；2） 在网络上传送对象的字节序列。
	在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。
	当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。

14.java垃圾回收（GC）机制详解
回收原因：垃圾回收，释放内存；程序员在编写代码时无需考虑内存管理；
明确回收对象：
	引用计数法。给对象添加一个引用计数器，每当有引用时，计数器+1，当引用失效时，引用-1，计数器为0时表明该对象不可能再被使用。缺点：难以解决对象之间相互引用的问题。
	可达性分析法。通过一系列称为“GC ROOTS”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即对象不可到达时），则证明该对象不可用。GC Roots对象：虚拟机栈中引用的对象、常量引用的对象、类静态属性引用的对象等
 
四种引用状态：（引用强度依次减弱）
 
强引用对象永远不会被垃圾回收，即使JVM会抛出OOM异常；软引用在内存足够时不会被回收，软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等；弱引用无论内存是否充足，都会回收被弱引用关联的对象；虚引用提供系统通知。
垃圾回收算法：
	标记清除算法：首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，但效率不高，且易产生大量不连续的内存碎片
	复制算法：将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。缺点：浪费大量内存。（商业上用于回收新生代）新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，Eden区和Survivor区的比例为8:1
	分代收集算法。根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适当的收集算法。大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。
垃圾回收器：
 
G1收集器：
将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合，一共有四类Region（Eden，Survior，Humongous和Old）。
	Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。
	Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。
	Full GC：如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.

15.java异常与回滚
异常的继承结构：Throwable为基类，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception。Error和RuntimeException及其子类成为未检查异常（unchecked），其它异常成为已检查异常（checked）。
 
Error异常：Error表示程序在运行期间出现了十分严重、不可恢复的错误，在这种情况下应用程序只能中止运行，例如JAVA 虚拟机出现错误。Error是一种unchecked Exception，编译器不会检查Error是否被处理，在程序中不用捕获Error类型的异常。一般情况下，在程序中也不应该抛出Error类型的异常。
RuntimeException异常：Exception异常包括RuntimeException异常和其他非RuntimeException的异常。RuntimeException 是一种Unchecked Exception，即表示编译器不会检查程序是否对RuntimeException作了处理，在程序中不必捕获RuntimException类型的异常，也不必在方法体声明抛出RuntimeException类。RuntimeException发生的时候，表示程序中出现了编程错误，所以应该找出错误修改程序，而不是去捕获RuntimeException。

Checked Exception异常：这也是在编程中使用最多的Exception，所有继承自Exception并且不是RuntimeException的异常都是checked Exception，上图中的IOException和ClassNotFoundException。JAVA 语言规定必须对checked Exception作处理，编译器会对此作检查，要么在方法体中声明抛出checked Exception，要么使用catch语句捕获checked Exception进行处理，不然不能通过编译
回滚：当一个方法中有多个数据库操作的时候，中间的数据库操作发生错误（抛出运行期异常RunTimeException），发生错误之前的所有数据库保存操作都回滚，即不保存

16.spring相关
Spring：类似于一个大工厂，可以为各种对象创建实例，因此能够整合其他模块，如mubatis、redis等
 
 
SpringMVC实现原理：
	配置阶段：spring基于servlet设计，配置环境，需要扫描的controller和service
	IOC阶段：初始化（加载配置文件、扫描到所有相关的类、初始化相关类并将其存入到IOC容器中、自动注入DI、初始化HandlerMapping、调用dispatcher、dispatcher调用controller）
SpringMVC工作流程：
	记载配置文件，扫描相关的包，完成初始化和依赖注入
	Dispatcher接受前端传来的url和提交的参数，并调用HandlerMapping处理映射器，找到对应的处理器Controller
	执行Controller，完成相关的业务逻辑和数据库相关操作，并返回response（ModelAndView）给HandlerAdapter
	HandlerAdapter返回结果到DispatcherServlet，进行解析和渲染，并返回给前端
SpringIOC（Inversion of Control）：控制反转 是一种设计思想，IOC意味着将设计好的对象交给容器控制，进行对象创建，不需我们主动控制区获取对象，反转意味着IOC容器帮我们查找即注入依赖对象，依赖对象的获取被反转了。优点：对象的创建进行统一管理；规范的生命周期管理；灵活的依赖注入，松散耦合；  IOC容器实际就是一个map对象，key为实例化的对象名，value为对象bean
补充：没有IOC容器之前，对象A依赖于对象B，则A只能new或者使用已有的对象B，无论创建还是使用，控制权都在对象A，当引入IOC容器之后，A依赖于B，则IOC容器会控制B的创建并将其注入到A中需要的地方，A获得B的过程由主动变为被动，这就是控制反转。获得依赖对象的过程被反转了  DI可以认为是IOC的实现方法
依赖注入（DI，Dependency Injection）：注入就是自动给属性赋值。对象自己不需要负责去寻找或是创建它们所依赖的对象，而是由容器（container）来维护对象之间的引用关系
面向切片服务（AOP）：在程序运行阶段，动态的将代码指定在特定位置进行执行，如一个系统用户登录后，进行相关操作需要验证用户，则可将验证用户作为切片在特定位置插入执行。在spring中一般用在系统层面，比如日志、权限管理、事务等，可在xml中为aop标签进行配置，其实现一般通过javaSE动态代理或cglib代理。

17.数据库索引
1）索引本质是一种数据结构，是为了帮助数据库高效获取数据的数据结构。
建立数据库索引的原因：查询是数据库最基本的功能之一，我们都希望查询效率尽可能的快，因此数据库设计者会从查询算法的角度进行优化，最基本的为顺序查询，其次为二分查询、二叉树查询等，但是数据本身的组织结构不可能完全满足各种查询算法的数据结构，因此在数据之外，数据库系统还维护满足特定算法的数据结构，这些数据结构以某种方式引用数据，这样就可以实现高级快速查找算法，这种数据结构就是索引。
2）目前，大部分数据库系统都采用B+树作为索引结构
B树与B+树实现原理：

 
 
18.JAVA设计模式




19.spring和mybatis事务分析
Mybatis强大之处：支持定制化SQL以及高级映射的持久层框架，通过mybatis插件自动生成sql语句，几乎避免了所有的jdbc代码和手动设置参数以及获取结果集；SQL与程序代码彻底分离，降低耦合度，便于统一管理和优化，支持动态拼接sql语句；支持java对象和字段关系映射。
相关问题：
#{}与${}区别：#{}会对参数进行解析，在sql语句中表示为？，传入参数后解析参数并传入；${}不会对参数进行解析，为拼接符，原样输出，在order by中用的较多。
Namespace对应dao接口，id为方法名，resulttype为返回结果类型，parameter为传入参数类型，当传入多个相同类型的参数时，可以使用@param注解的方式解决。
Mybatis动态sql拼接：在xml中可以使用标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能；9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。
Mybatis分页：分页插件？业务逻辑中定义page显示。

20.JVM内存区域
分为共享内存和非共享内存两种。
共享内存：
堆（heap）：专门用来存放对象实例、数组，GC发生区域。
方法区：常量、静态变量和编译后的代码，加载类的类定义数据等。
非共享内存（线程私有）：
程序计数器：是当前线程执行的字节码的位置指示器，可以用来进行线程切换等功能。
虚拟机栈（stack）：存放对象引用、基本类型数据以及方法操作码。
本地方法栈：其他语言代码的方法。
永久代：永久代是用于存放静态文件，如Java类、方法等，包括：类的方法(字节码...)类名(Sring对象)  .class文件读到的常量信息 class对象相关的对象列表和类型列表  JVM创建的内部对象  JIT编译器优化用的信息

21.Collection集合相关问题
HashMap 和 ConcurrentHashMap 的区别：ConcurrentHashMap引入分段锁的概念，整个 ConcurrentHashMap 由一个个 Segment 组成，并对segment进行上锁，在操作时通过hashcode哪一个segment执行，以此保证并发线程安全性。Hashtable对所有修改方法进行同步锁，执行效率低。
Comparable和Comparator区别：实现了Comparable接口的类就具备了相互比较的功能，实现类可以调用comparaTo方法进行比较（A.comparaTo（B））。实现Comparator的类，要实现一个比较器类，来进行两个对象的比较（传入两个比较对象）。



22.内存泄漏
内存泄漏：指无用的对象持续占有内存或无用对象的内存得不到即时释放，从而造成内存资源的浪费。内存泄漏的对象满足两个特点：对象是可达的即在可达性上，是存在链路与其相连的；对象是无用的，即程序以后不会再使用这些对象。
如何监测内存泄漏：通常使用一些工具来检查java程序的内存泄漏问题，其工作原理都大同小异，通过对java对象的监测，将内存管理的所有信息进行统计、分析、可视化，让开发人员根据信息来判断是否有内存泄漏的问题。
几种情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收；
各种连接，如数据库连接、socket连接、io连接等，除非显示的调用close方法，否则不会被GC回收。

23.性能优化



24.JAVA IO与NIO问题
Java语言跨平台性：java语言在机器和编译程序之间加了一个中间层，java虚拟机，不同平台有不同的java虚拟机，java虚拟机解释字节码使其在各个平台都可以运行。运行过程：JAVA源代码-----编译器-----jvm可执行的字节码-----jvm----jvm中解释器-----机器可执行的二进制码----程序运行。
采用字节码好处：解决传统解释型语言执行效率低的问题；配合jvm实现跨平台
字节流与字符流的区别：字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。（1）字节流在操作时不会用到缓冲区（内存），直接对文件本身进行操作；字符流在操作时使用了缓冲区，通过缓冲区再操作文件。（2）操作区别：字节流实现InputStream和OutStream接口操作，字符流实现reader和writer接口操作。（3）转换。从字节流转化为字符流时，实际上就是byte[]转化为String，而在字符流转化为字节流时，实际上是String转化为byte[]。
字节流输入和输出类结构图：
 
字符流的输入和输出类结构图：
 
从Byte 数组、StringBuffer、本地文件、管道数据、基础类型数据等操作数据；
IO流的分类：
- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。
字节流还是字符流更好：所有的文件在硬盘或在传输时都是以字节的方式进行的，包括图片等都是按字节的方式存储的，而字符是只有在内存中才会形成，所以在开发中，字节流使用较为广泛；字符流利用缓冲区内存，读取速度快。
Filter流：Filter Stream是一种IO流主要作用是用来对存在的流增加一些额外的功能，像给目标文件增加源文件中不存在的行数，或者增加拷贝的性能等，是利用修饰者设计模式设计的类。FilterInputStream, FilterOutputStream, FilterReader and FilterWriter等接口。
NIO：Java NIO 是 java 1.4, 之后新出的一套IO接口NIO中的N可以理解为Non-blocking，非阻塞IO流，操作的管道channel和缓冲区buffer。
IO与NIO：IO是面向流的，NIO是面向缓冲区的。
	标准的IO编程接口是面向字节流和字符流的。而NIO是面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer缓冲区写入到通道中；（ NIO中的所有I/O操作都是通过一个通道开始的。）
	Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；
	Java NIO是面向缓存的I/O方法。 将数据读入缓冲器，使用通道进一步处理数据。 在NIO中，使用通道和缓冲区来处理I/O操作。

25.RESTful


26.Spring事务分析
事务的概念：事务是访问数据库的一个操作序列，数据库系统通过事务集来完成对数据的存取。四个原则：ACID
原子性：即事务要么被全部执行，要么被全部不执行
一致性：即状态转换必须是由一种正确的状态转换到另外一种正确的状态
隔离性：事务相互间必须不能被影响
持久性：事务提交后将被永久保存
Spring事务管理步骤：
[1]	PlatformTransactionManager：（平台）事务管理器
[2]	TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)
[3]	TransactionStatus： 事务运行状态
①所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。Spring并不直接管理事务，而是提供了多种事务管理器（PlatformTransactionManager接口），mybatis事务管理器：
 
②TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。
 
 
并发事务带来的问题：脏读、丢失修改、不可重复读、幻读。
	事务隔离级别避免并发事务带来的问题；
	事务传播行为是为了解决业务层方法之间互相调用的事务问题；
	事务超时属性，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务
	定义事务回滚规则
③ TransactionStatus接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息.
 
实际应用：（1）基于原始注解类实现（编程式事务管理）；（2）基于< tx> 和< aop>命名空间的声明式事务管理（基于AspectJ的声明式事务管理）；（3）基于 @Transactional 的全注解方式
