1.协议体系结构
OSI七层结构：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
TCP/IP四层结构：数据链路层、网络层、传输层、应用层
	应用层：负责处理应用程序的逻辑，如何包装数据，进行数据的展示。应用层协议定义的是应用进程间的通信和交互规则，如域名系统DNS协议：可以将域名和IP地址相互映射，方便人们访问、HTTP协议：提供一种发布和接收HTML页面的方法、支持电子邮件的SMTP协议、文件传输FTP协议等
	传输层：负责向两台主机间通信提供通用的数据传输服务。两台主机上的应用程序提供端到端的通信。常见协议，如TCP协议：传输控制协议，提供面向连接的可靠的数据传输服务、UDP协议：用户数据报协议，提供无连接的、快速的数据传输服务，但不保证可靠性。
	网络层：实现数据报的选路和转发，把传输层产生的报文段或用户数据报封装成数据包进行传送。互联网是由大量的异构网络通过路由器相互连接起来的，IP协议：根据数据报的IP地址选择合适的路径从而到达目的主机。
	数据链路层：负责将网络层交下来的IP数据报组装程帧，在两个相邻节点间的链路上传送帧。ARP（地址解析协议）：实现IP地址到物理地址的转换、RARP（逆地址解析协议）：实现从物理地址到IP地址的转换
 
网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）

2. TCP三次握手和四次挥手
 
三次握手：【1】客户端向服务器端发送带有syn（syn=j）标志的数据包，并进入到SYN_SEND状态，等待服务器确认；【2】服务器收到带有syn的数据包，确认客户端的syn（ACK = j+1），并返回带有SYN+ACK包（syn = k），此时服务器进入SYN_RECV状态；【3】客户端收到SYN+ACK包，并返回ACK包（syn=k+1），此包发送完毕，双方进入ESTABLISHED状态，完成三次握手。
握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据
 
四次挥手：【1】客户端-发送一个FIN，用来关闭客户端到服务器的数据传送 【2】服务器-收到这个FIN，它发回一个ACK，确认序号为收到的序号加1 。和SYN一样，一个FIN将占用一个序号 【3】服务器数据传输完毕后-关闭与客户端的连接，发送一个FIN给客户端 【4】客户端-发回ACK报文确认，并将确认序号设置为收到序号加1

3.TCP与UDP协议区别
 
可靠性：TCP是面向连接的数据传输协议，能够保证数据传输的可靠性；UDP用户数据报协议，是无连接的数据传输，可靠性不足；
速度：无连接的UDP传输速度更高，TCP面向连接传输速度慢；
场景：因为两种协议特点的不同，TCP一般用于文件传输、发送和接收邮件等场景，而UDP较为适合QQ语音、QQ视频等即时通信的情况。

4.浏览器输入url地址-->显示主页的过程
 
	浏览器通过域名和DNS协议获取服务器端的IP地址
	浏览器向服务器端发送HTTP请求，HTTP协议生成HTTP请求报文
	TCP/IP协议将请求报文发送到服务器端，服务器端处理请求，生成html响应并返回
	浏览器获得HTML进行显示
 
5.socket全面理解
概念：socket（套接字）是系统提供的用于网络通信的方法，可以看做是TCP/IP协议操作的抽象。在java中Socket类有accetp、send、connect等方法，通过传入IP地址、端口号等信息在客户端与服务器端发送与接收消息。
Socket建立网络连接的过程：建立socket连接至少需要一对套接字，其中一个运行在客户端，另一个运行于服务器端。连接过程分为三个步骤：
	服务器监听：服务器端socket处于等待连接状态，监控网络的状态，等待客户端的连接请求
	客户端请求：客户端的套接字提出连接请求，要连接的目标是服务器端的套接字，为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
	连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求

6.HTTP连接
HTTP协议即超文本传送协议(Hypertext Transfer Protocol ) 
http1.0短连接：客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接，从建立连接到关闭连接的过程称为“一次连接”。
从HTTP/1.1起，默认使用长连接，用以保持连接特性：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

7.HTTP状态码
 
1XX：表示临时响应并需要请求者继续执行操作的状态码。
2XX：表示成功处理了请求的状态码。
3XX：表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。
4XX：表示请求可能出错，妨碍了服务器的处理。
	400     //错误请求  服务器不理解请求的语法
401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
403     //禁止  服务器拒绝请求
404     //未找到  服务器找不到请求的网页
405     //方法禁用  禁用请求中指定的方法
406     //不接受  无法使用请求的内容特性响应请求的网页
408     //请求超时  服务器等候请求时发生超时
410     //已删除  如果请求的资源已永久删除，服务器就会返回此响应
5XX：表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错

8.RPC详解
概念：RPC远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层技术的协议，RPC使得开发分布式程序向开发本地程序一样简单。
运行方式：RPC采用客户端（服务调用方）/服务器端（服务提供方）的模式，都运行在各自的JVM中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。RPC主要依赖的技术包括序列化、反序列化和数据传输协议，是一种调用与实现相分离的设计。
RPC主要方案：RMI（JDK自带）、dubbo（阿里）等
Dubbo：阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成
 
1. 服务容器负责启动，加载，运行服务提供者。 
2. 服务提供者在启动时，向注册中心注册自己提供的服务。 
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。 
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
消息队列：是在消息的传输过程中保存消息的容器。“消息” 是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。
应用场景：通过异步处理提高系统性能（通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务）；降低系统的耦合（模块之间不存在直接调用，那么系统的耦合性就会更低）；常见的消息队里：rabbitMQ、ActiveMQ、RocketMQ等。
